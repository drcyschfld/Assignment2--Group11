/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"
#include "digital_io.h" // Include the header file for digital I/O module

// Function prototypes
void enable_clocks(void);
void initialise_board(void);
void enable_interrupt(void);

// Callback function to be called when button is pressed
void button_press_callback(void)
{
    // Implement your desired functionality here
    // For example, toggle an LED
    chase_led();
}

int main(void)
{
    // Enable clocks for peripherals
    enable_clocks();

    // Initialize GPIO pins for LED and button
    initialise_board();

    // Set the button press handler to the callback function
    set_button_press_handler(button_press_callback);

    // Enable interrupt for button press
    enable_interrupt();

    // Infinite loop
    for (;;) {
        // This loop will continuously execute after setting up the interrupts
    }
}

// Enable clocks for desired peripherals (GPIOA, C and E)
void enable_clocks(void) {
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIOEEN;
}

// Initialise the discovery board I/O (just outputs: inputs are selected by default)
void initialise_board(void) {
    // Get a pointer to the second half word of the MODER register (for outputs pe8-15)
    uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1;
    *led_output_registers = 0x5555;
}

// Enable interrupt for button press
void enable_interrupt(void) {
    // Disable the interrupts while messing around with the settings
    // otherwise, can lead to strange behavior
    __disable_irq();

    // Enable the system configuration controller (SYSCFG in RCC)
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

    // Configure PA0 as EXTI0 interrupt source
    SYSCFG->EXTICR[0] &= ~SYSCFG_EXTICR1_EXTI0_Msk; // Clear bits
    SYSCFG->EXTICR[0] |= SYSCFG_EXTICR1_EXTI0_PA;  // Set EXTI0 to PA0

    // Configure EXTI0 to trigger on rising edge
    EXTI->RTSR |= EXTI_RTSR_TR0;

    // Enable EXTI0 interrupt
    EXTI->IMR |= EXTI_IMR_MR0;

    // Set EXTI0 interrupt priority and enable it
    NVIC_SetPriority(EXTI0_IRQn, 1);
    NVIC_EnableIRQ(EXTI0_IRQn);

    // Re-enable all interrupts (now that we are finished)
    __enable_irq();
}


