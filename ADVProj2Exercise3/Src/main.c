/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"
#include "initialise.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void (*timer_overflow_2)() = 0x00;
void (*timer_overflow_3)() = 0x00;

//global variable definition:
volatile uint8_t led_pattern_flag = 1;


//function declarations:
void timer_set(uint16_t delay_in_milliseconds);

void TIM2_IRQHandler(){

/*
 * function info:
 * This function is the function that is called when the TIM2 interrupt occurs.
 * The function checks whether the timer_overflow variable is set to another function.
 * If timer_overflow is set, calls the function stored in the variable
 */

	if (timer_overflow_2 != 0x00) {
			timer_overflow_2();
		}

	reset_UIF_2();

}

void TIM3_IRQHandler(){


	if (timer_overflow_3 != 0x00) {
				timer_overflow_3();
			}

	reset_UIF_3();
	disable_timer_3();
}

void LED_on (){
/*
 * function info:
 * this function turns the LEDs on or off one by one.
 * if all the LEDs have turned on, they will start to turn off one by one
 * if all the LEDs are off, they will start to turn on one by one
 */

	uint8_t *LED_output_register = ((uint8_t*)&(GPIOE->ODR)) + 1;

	if (*LED_output_register == 0b11111111){

		led_pattern_flag = 0;

	}

	else if (*LED_output_register == 0b00000000){

		led_pattern_flag = 1;

	}

	if (led_pattern_flag == 0){

		uint8_t LED_right_shift = *LED_output_register >> 1;
		*LED_output_register = LED_right_shift;

	}

	else if (led_pattern_flag == 1){

		uint8_t LED_left_shift = *LED_output_register << 1;
		uint8_t LED_pattern = LED_left_shift | 0x1;
		*LED_output_register = LED_pattern;

	}


}

void set_max_count(timer_info *s, uint16_t max_count_value){
/*
 * function info:
 * this function takes in a variable of type timer_info and a value and sets the variable.max_count to the value
 */

	s->max_count = max_count_value;

}

void set_psc_value(timer_info *s, uint16_t psc_int){
/*
 * function info:
 * this function takes in a variable of type timer_info and a value and sets the variable.psc_value to the value
 */

	s->psc_value = psc_int;

}

void LED_off (){

	uint8_t *LED_output_register = ((uint8_t*)&(GPIOE->ODR)) + 1;
	uint8_t LED_pattern = 0x00;
	*LED_output_register = LED_pattern;

}

timer_info delay_set(uint16_t delay_in_milliseconds){
/*
 * function info:
 * this function takes in the requested delay in milliseconds and sends it to the set_max_count function.
 * once the function has completed it returns a variable called timer_x_info of type timer_info that has information for max_count and the psc_value
 * max count values:
 * 0x2710 = count of 10000 (10 seconds),
 * 0x1388 = count of 5000 (5 seconds),
 * 0x3E8 = count of 1000 (1 second)
 */

	timer_info timer_x_info;
	//uint16_t max_count_value = 0x3E8;
	uint16_t psc_value = 0x1F3F;
	set_max_count(&timer_x_info, delay_in_milliseconds);
	set_psc_value(&timer_x_info, psc_value);

	return timer_x_info;
}

void timer_2_set(uint16_t delay_in_milliseconds){

/*
 * function info:
 * this function takes in a delay in milliseconds and passes it to the delay_set function.
 * The return of the delay_set function is saved in the variable timer_x_info which is then
 * passed to the timer_initialisation function to start the delay
 */

	timer_info timer_x_info = delay_set(delay_in_milliseconds);

	timer_2_initialisation(&timer_x_info);
}

void timer_3_set(uint16_t delay_in_milliseconds){

/*
 * function info:
 * this function takes in a delay in milliseconds and passes it to the delay_set function.
 * The return of the delay_set function is saved in the variable timer_x_info which is then
 * passed to the timer_initialisation function to start the delay
 */

	timer_info timer_x_info = delay_set(delay_in_milliseconds);

	timer_3_initialisation(&timer_x_info);
}

void one_shot(uint16_t delay_in_milliseconds , void (*func_ptr)()){

	timer_overflow_3 = func_ptr;

	timer_3_set(delay_in_milliseconds);

	enable_interrupt_timer_3();

}

int main(void)
{
	general_initialisation();

	LED_off();

	timer_overflow_2 = &LED_on;

	timer_2_set(0x3E8);

	enable_interrupt_timer_2();

	one_shot(0x157C , &LED_off);



    /* Loop forever */
	for(;;);
}
